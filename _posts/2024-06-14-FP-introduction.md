---
title: "Introduction"
date: 2024-05-18
---

## Functional Programming

All books about functional programming start with a great poem that is so vivid and enlightened that
I for the other hand will start in another way. I will make a case that 1000x programers do not need functional programming,
furthermore, programmers that do not need functional programming do not need object oriented paradim either, heck take structed programming of the view too. Give them all the true power of a computer with GO/TO statements, direct memory assigments, if you are one of those brillian people that can computer at a level that a current computer does, than you do not need this book. This book is for developers that are lazy, low on resources, time and one to get work right the first time always.
Structured Programming, Functional Programming, Object Oriented programming.

Functional programming came into my one day and I have never been the same. Its like all of the sudden all my decisions where easy to make, and I persued one thing ever since, understanding functional programming.
I've been coding for over a decade, and I am from the lucky few that can do functional programming for a living.

## AI

By the time I write this <https://www.scientificamerican.com/article/ai-will-become-mathematicians-co-pilot/>
I can pretty much guarantee that everything out there has something about AI, this but is no different.
Even math is getting tha contagious stuff. I think developers are finally getting promoted to not implement details, but to rather write test.... wait what?. To prove my point I will go back to the Terence Tao interview and how the like of an averge Mathematacial like of Andrew Wiles back in 1986.

I want you to live in the life of a Math professional. Imagine you are motivated by the fame and want to takle on of the millenium problems, but these a lot of work to do. Like anything done previously in history, you would like to divide and conquer, reducing the problem to smaller parts. Now, for argument purposes, say that division into modules lets you with 1000 modules to work on, each of which can take up to 100 days of work. Thats almost 280 years of a single person work, and thats in a ideal no delay project. There is an argument for parallizing the modules work (if none of them depende on eachother) one could ask 1000 mathematicians to provide a solution for each module, and effectivelly reducing the time of proof to just 100 days.
However, the problem comes now with the artifact delivered by each person. Pushing more into the the though experiment, each module proof can be thousand of pages long and can take up to year in understanding it, also because its a pen and paper ind of work, you would have to go undividually through each person line and really trust their thought process, or redo the proof yourself, pre-AI mathematicians can only trus few, no more that 4 blindly in their work. Its seems like we are better of doing it ourself and hoping we could catch a break. Ideally we would like to trust blindly the work of each mathematician, by having something in the middle that we can trust and accurately describe what we want. And here lies the intuition of this book, what can be that thing in the middle that can help us?

Comming now back to modernity, and imagine yourself being responsible of a HUGE, low level critical system, and you are responsible for mantaining and improve it. Like anything huge and low level, everything is spagetti code a

I believe the problem that functional programmers face is the dificulty to create implementations that map their types, or even worse starting at blank screen. AI can help you get some momentum

I believe that theres no more excuse regarding so thats why I propose you the reader, and me also, in navigating the world of functional programming, but not just with one lense but rather several lenses at a time. People new to functional programming.

## The big take of the book

Normaly, when learning Functional programming, you are forced to pick a languange and stick to it until the end where you find the hard parts. You would start by some simple syntax and then move, like a dry manual, through all the syntax of the languange.

I believe that to better understand functional programming one should squint, and not worry about the minutia but rather think about the bigger picture. Regarless weather you are working with a Monad, in Haskell, OCaml, Scala or Assembler. As long as you keep the bigger abstractions in mind you can profit inmensly from Functional programming. Therefore, we will learn functional programming using several language at the same time so we get to compare.

